#加速优化Angular应用

## 性能的考虑

AngularJS是一个非常优秀且改变攻城狮思维方式的框架，能够帮助我们有调理的组织代码的MV*机构。    
虽然他本身已经built-in了很多性能优化工作，普通富前端应用可能不需要考虑太多，但毕竟框架很庞大，碰到逻辑复杂的场景，难免遇到瓶颈。   
Google一波已经有不少优化方案了，这里再抛出一些，欢迎砸玉~

## yes，首当其冲的就是双向绑定机制

关于性能考究 最直接也最关键的就是：减少angular内部$$watchers实例数量，以提高$digest循环的性能。也就可以保证了应用足够稳定和对交互的快速响应。

每当一个Model更新（不管是用户直接在视图中操作引起的，还是controller里通过注入的service操作改变），Angular内部都会执行__2到10遍__（Dirty Checking）$digest循环遍历__整个__应用去查找挂在$scope下的各Model的更新，期间同时处理Model可能的再次变更。

当我们创建一个数据绑定时，会隐式创建更多的$$watchers和$scope等对象，因为处于$digest监控范围，他们反过来也会使每次$digest执行更久。当应用逻辑不断复杂时，我们更需要留心。

## 几个方面

### 合理利用一次性绑定机制

Angular最近的几次更新中引入了一个很有用的功能：一次性的渲染模板某些变量，并且他们不会收到未来Model变化的影响。这对开发者改善应用性能是个福音，在这之前我们可能是这样设置模板数据：

```
<i>{{ tip }}</i>
```
使用一次性变量渲染语法则可以这样：

```
<i>{{ ::tip }}</i>
```

这样当Angular按常规处理完DOM和该变量后，他会在内部$$watchers的监控列表中删除这些一次性变量。

这非常有用了。我们知道因为便捷背后的Dirty Checking，当Angular管理有2000个双向绑定时，应用的反应速度就会可感知的变慢。越少的绑定数量对应用的性能加速越好。这种做法简单快速，可以有效减少$$watcher的负担。

### $scope.$apply() or $scope.$digest()？

使用Angular的过程中，总有一阵子掉进过 $scope.$apply()的坑里。一不小心就会被滥用，比如解决不同插件间的逻辑等。这不是使用API的最好方式，虽然有时被误解，但他确实是相当简洁。

$scope.$apply被设计用来告诉Angular一个Model在他的生命周期&监控范围外发生了变化，仅此而已。我们调用他只是告诉Angular去更新一下$scope下的各Model。在正确的时机使用他非常重要，否则会降低应用性能。如果在不合适的时机使用他，还会被抛出一些 errors，比如“堆积过高的调用栈”。

我们通常使用三方插件，他们可能在Angular管理之外改变了DOM，此时就是$scope.$apply方法须要出场的时候了：    
当DOM更新完毕后（需要这层逻辑处于可控状态），调用$scope.$apply方法，他会在内部开始$digest循环，从而达到在Angular体系外更新模型。
